#pragma enable_d3d11_debug_symbols

#include "DataStructure/RayFlag.compute"
#include "Ray.compute"
#include "RayHit.compute"
#include "DataStructure/LightInfo.compute"
#include "DataStructure/LightHit.compute"
#include "DataStructure/SecRaysAtHit.compute"
#include "Intersect/SphereIntersectUtils.compute"
#include "Intersect/TriangleIntersectUtils.compute"
#include "Primitive/Primitive.compute"
#include "BVH/RTBoundingBox.compute"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

// Camera
float4 _CameraForward;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float _CameraOrthographicSize;
float4x4 _CameraLocalToWorld;

// Ray Generation
int _RayGenID;

//Skybox
Texture2D<float4> _SkyboxTexture;
SamplerState sampler_SkyboxTexture;

// Texture
Texture2DArray _MatTexture;

// Primitive
int _NumOfPrimitive;
StructuredBuffer<Primitive> _Primitives;
StructuredBuffer<float4x4> _WorldToPrimitives;

// BVH
StructuredBuffer<RTBoundingBox> _BVHTree;

// Light
int _NumOfLights;
StructuredBuffer<LightInfo> _Lights;

// Ambient
float3 _AmbientLightUpper;

// For VR eye difference
bool _LeftEye;

// Foveated Specific
float4 _frustumVector; //frustum info (width, height, distance), a is unused
float4 _viewVector; //vector of the gaze view (x, y, z), a is unused
float _innerAngleMax; //area of foveal region
bool _runHalfRes; //tells the shader we're generating the lower res image for ray sharing
bool _runNoFoveated; //tells the shader to make the frame without using foveated rendering
bool _onlyOneSample; //tells the shader to ignore the number of samples to use
bool _showTint; //should we tint based on region
bool _showOverlay; //should we show the overlay
static const float _overlaySize = 0.005f; //size of overlay in angle
float _debugRegionBorderSize;
RWTexture2D<float4> HalfRes; //half resolution texture for ray sharing

// Placeholder
float3 missShader(float3 direction) {
    // Sample the skybox and write it
    float theta = acos(direction.y) / -3.14159265359f;
    float phi = atan2(direction.x, -direction.z) / -3.14159265359f * 0.5f;
    return _SkyboxTexture.SampleLevel(sampler_SkyboxTexture, float2(phi, theta), 0).xyz;
}

#include "Intersect/IntersectShaderCollection.compute"

#include "Light/CustomLights.compute"

#include "Shading/CustomShaderCollection.compute"

#include "Custom/RayGeneration/CustomRayGeneration.compute"

#include "RayCasting/Trace.compute"


// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// MAX_RAY_GENERATION = 4;
// MAX_SECONDARY_RAYS_PER_GENERATION = 4;

static const int MAX_RAY_GEN = 4;
static const int MAX_RAY_PER_LEVEL = 2;

int childRayOffset(int myLevel) 
{
    return (myLevel + 1) * MAX_RAY_PER_LEVEL;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
    uint width, height;
    Result.GetDimensions(width, height);
    if(_runHalfRes){
        //divide width and height by 2, because we're rendering to the half res Texture
        width = width / 2;
        height = height / 2;
    }

    //calculate offset
    //currently static numbers for the VR cameras
    float FOV = 90;
    //float FOVRad = 1.5708;
    float xOffset = 11;
    if(_LeftEye){
        xOffset = -11;
    }
    float yOffset = 10;

    int2 finalXY = {id.x + ((width * xOffset) / FOV), id.y + ((height * yOffset) / FOV)};

    //wrap around if the offset places us outside the array bounds
    if(finalXY.x < 0){
        finalXY.x += width;
    }
    if(finalXY.x >= width){
        finalXY.x -= width;
    }
    if(finalXY.y < 0){
        finalXY.y += height;
    }
    if(finalXY.y >= height){
        finalXY.y += height;
    } 

    //get relative screen location (-0.5 through 0.5) for angle calculations
    float widthF = width;
    float screenXF = id.x;
    float heightF = height;
    float screenYF = id.y;
    float relativeScreenX = (screenXF/widthF) - 0.5;
    float relativeScreenY = (screenYF/heightF) - 0.5;

    //check the angle distance from the look direction
    //angle = arccos(a.b / magA + magB)
    //A is the vector to this pixel
    //x = (texX - 0.5) * width, y = (texY - 0.5) * height, z = given distance
    float3 vecA = {(relativeScreenX) * _frustumVector.x, (relativeScreenY) * _frustumVector.y, _frustumVector.z};
    //B is the direction vector of the gaze
                
    float dot = (vecA.x * _viewVector.x) + (vecA.y * _viewVector.y) + (vecA.z * _viewVector.z);
    float magA = sqrt((vecA.x * vecA.x) + (vecA.y * vecA.y) + (vecA.z * vecA.z));
    float magB = sqrt((_viewVector.x * _viewVector.x) + (_viewVector.y * _viewVector.y) + (_viewVector.z * _viewVector.z));
    float angle = acos((dot / (magA * magB)));

    if((angle < (_innerAngleMax - 0.005f) || angle > ((_innerAngleMax * 3) + 0.005f)) && _runHalfRes){ //add small bump to avoid edge cases
        HalfRes[finalXY] = float4(1,0,1,1); //don't render here because there will be no pulling from here
        return;
    }

    if(!_runHalfRes && _showOverlay && angle <= _overlaySize){
        //just render pink to show center of user gaze
        Result[finalXY] = float4(1,0,1,1);
        return;
    }

    //can be used to debug if we're in the angle, tints are better though
    //if(angle > _innerAngleMax){
    //    Result[finalXY] = float4(1,0,0,1);
    //    return;
    //}

    uint numberOfRay = NumberOfRay(width, height, id, _RayGenID);
    if(_onlyOneSample){
        numberOfRay = 1;//only have one ray
    }
    if(!_runNoFoveated){
        if(_runHalfRes){
            numberOfRay = 1; //only have one ray
        }
        else{
            if(angle > _innerAngleMax){
                numberOfRay = 1; //only have one ray outside of the inner radius
            }
            if(angle > (_innerAngleMax * 2)){
                //only use low res (don't shoot rays)
                numberOfRay = 0;
            }
            if(angle > (_innerAngleMax * 3)){
                //outside viewable area (don't render)
                Result[finalXY] = float4(0,0,0,1);
                return;
            }
        }
    }

    float4 finalColor = float4(0.0f, 0.0f, 0.0f, 0.0f);

    Ray _secondaryRayStack[MAX_RAY_GEN * MAX_RAY_PER_LEVEL];
    int srSbilingAtEachLevel[MAX_RAY_GEN];
    for (uint e = 0; e < MAX_RAY_GEN; e++)
    {
        srSbilingAtEachLevel[e] = -1;
    }

    [fastopt] for (uint i = 0; i < numberOfRay; i++) 
    {
        Ray ray = RayGeneration(width, height, id, _RayGenID, i);

        // Trace
        RayHit hit = Trace(ray);    // Exclude nothing

        float3 result;
        if (hit.primitiveId == -1) 
        {
            // Miss Shader
            result = missShader(ray.direction);
        } 
        else 
        {
            // -
            
            int srLevel = -1;
            float3 secRayCombinedColor = float3(0, 0, 0);
            /*
            // TODO: Refactor this to avoid special case for primary ray
            SecRaysAtHit secRaysAtHit = CreateSecRaysAtHit();   // TODO: Optimization: Avoid initialize the internal Ray array
            SecRays(ray, hit, secRaysAtHit);
            
            // Check if there is secondary rays
            if (secRaysAtHit.srays[0].tmin > -1 * 1.#INF) 
            {
                srLevel = srLevel + 1;
                srSbilingAtEachLevel[0] = 0;
                [fastopt] for (int j = 0; j < MAX_RAY_PER_LEVEL; j++) //fastopt added for faster compilation
                {
                    _secondaryRayStack[srLevel * MAX_RAY_PER_LEVEL + j] = secRaysAtHit.srays[j];  // Copy to secondary rays stack
                }

                [fastopt] while (srLevel > -1)
                {
                    if (srSbilingAtEachLevel[srLevel] < MAX_RAY_PER_LEVEL)
                    {
                        int secRayIndex = srLevel * MAX_RAY_PER_LEVEL + srSbilingAtEachLevel[srLevel];
                        if (srLevel < (MAX_RAY_GEN - 1))
                        {
                            if (srSbilingAtEachLevel[srLevel + 1] < 0) 
                            {
                                RayHit secHit = Trace(_secondaryRayStack[secRayIndex]);
                                // -
                                if (secHit.primitiveId == -1)
                                {
                                    _secondaryRayStack[secRayIndex].color = missShader(_secondaryRayStack[secRayIndex].direction);
                                    // Move to sibling
                                    srSbilingAtEachLevel[srLevel] = srSbilingAtEachLevel[srLevel] + 1;
                                }
                                else
                                {
                                    SecRaysAtHit _hit = CreateSecRaysAtHit();   // TODO: Optimization: Avoid initialize the internal Ray array
                                    SecRays(_secondaryRayStack[secRayIndex], secHit, _hit);
                                    [fastopt] for (int i = 0; i < MAX_RAY_PER_LEVEL; i++) //fastopt added for faster compilation
                                    {
                                        _secondaryRayStack[childRayOffset(srLevel) + i] = _hit.srays[i];  // Copy to secondary rays stack
                                    }
                                    // Move to children
                                    srLevel = srLevel + 1;
                                    srSbilingAtEachLevel[srLevel] = 0; // Start from the first index of my children
                                }
                            }
                            else
                            {
                                // Back from children. Calculate the ray color from children rays
                                srSbilingAtEachLevel[srLevel + 1] = -1;
                                float3 children = float3(0, 0, 0);
                                [fastopt] for (int c = 0; c < MAX_RAY_PER_LEVEL; c++) //fastopt added for faster compilation
                                {
                                    children = children + _secondaryRayStack[childRayOffset(srLevel) + c].color * _secondaryRayStack[childRayOffset(srLevel) + c].weight;
                                }
                                RayHit secHit = Trace(_secondaryRayStack[secRayIndex]); //TODO: Optimization. Avoid doing trace again.
                                // -
                                _secondaryRayStack[secRayIndex].color = ClosestHit(
                                                                        _secondaryRayStack[secRayIndex],
                                                                        secHit,
                                                                        _AmbientLightUpper,
                                                                        children
                                                                    );
                                // Move to sibling
                                srSbilingAtEachLevel[srLevel] = srSbilingAtEachLevel[srLevel] + 1;
                            }
                        }
                        else
                        {
                            // The deepest iteration. We only allow ray-scene intersection. No more secondary ray spawning.
                            RayHit secHit = Trace(_secondaryRayStack[secRayIndex]);
                            // -
                            if (secHit.primitiveId == -1)
                            {
                                _secondaryRayStack[secRayIndex].color = missShader(_secondaryRayStack[secRayIndex].direction);
                            }
                            else
                            {
                                _secondaryRayStack[secRayIndex].color = ClosestHit(
                                                                        _secondaryRayStack[secRayIndex],
                                                                        secHit,
                                                                        _AmbientLightUpper,
                                                                        float3(0, 0, 0) // No more secondary hit
                                                                    );
                            }
                            
                            // Move to sibling
                            srSbilingAtEachLevel[srLevel] = srSbilingAtEachLevel[srLevel] + 1;
                        }
                    }
                    else
                    {
                        // Finish iterating this level. Fallback to parent.
                        srLevel = srLevel - 1;
                    }
                }
                srSbilingAtEachLevel[0] = -1;

                [fastopt]for (int c = 0; c < MAX_RAY_PER_LEVEL; c++) //fastopt added for faster compilation
                {
                    secRayCombinedColor = secRayCombinedColor + _secondaryRayStack[c].color * _secondaryRayStack[c].weight;
                }
            }*/ //attempting removal of secondary rays

            // Closet Hit Shader
            result = ClosestHit(
                ray,
                hit,
                _AmbientLightUpper,
                secRayCombinedColor
            );
        }
        
        if(_runNoFoveated){
            finalColor += float4(result, 1) / numberOfRay; //just use raw ray color
        }
        else{
            if(_runHalfRes){
                finalColor += float4(result, 1) / numberOfRay; //just use raw ray color
            }
            else{
                if(angle <= _innerAngleMax){
                    finalColor += float4(result, 1) / numberOfRay; //just use raw ray color
                 }
                else{
                    finalColor += float4(result, 1) / (numberOfRay + 1); //numberOfRay + 1 because we will be adding the color of the half res ray
                }
            }
        }
    }
    //add shared Ray
    if(!_runHalfRes && !_runNoFoveated){
        if(angle > _innerAngleMax){
            finalColor += HalfRes[finalXY/2] / (numberOfRay + 1);
        }
        //finalColor = HalfRes[finalXY/2]; //copy over half res for debug
        //also add tint if needed
        if(_showTint){
            if(abs(angle - _innerAngleMax) <= _debugRegionBorderSize){
                finalColor += float4(0,0.1f,0,0); //green border
            }
            else{
                if(angle <= _innerAngleMax){
                    finalColor += float4(0,0,0.1f,0); //blue inside
                }
                if(angle > _innerAngleMax && angle <= _innerAngleMax * 2){
                    finalColor += float4(0.1f,0,0,0); //red outside
                }
                if(angle > (_innerAngleMax * 2)){
                    finalColor += float4(0.1f,0.1f,0,0); //yellow in far region
                }
            }
        }
    }

    if(_runHalfRes){
        //render to the half texture
        HalfRes[finalXY] = finalColor;
    }
    //test change to force recompile.....
    Result[finalXY] = finalColor;
    //Result[id.xy] = finalColor;
    
}
